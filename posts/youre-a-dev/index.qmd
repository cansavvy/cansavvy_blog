---
title: "3  signs you might accidentally be a software developer"
author: "Candace Savonen"
date: "2023-08-29"
categories: [data science, informatics, research]

---

```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```


1. You have written code to build something in the past.
2. You are currently writing code to build something in the present.
3. You will continue to write code to build things in the future. 

<br> 
Software developers' jobs are often defined something like this: 

** Software developers use programming to build **software** that meets the needs of **users**.**

Let's break this down: 

- `Software` is often meaning a collection of instructions, data, or computer programs that are used to run machines and carry out particular activities -- this can include but isn't limited to: 
  - Scripts
  - Workflows
  - Pipelines
  - Algorithms and computational methods 

Scientific software for cancer research includes all of the above items pretty frequently but scientists often don't think of themselves as software developers. I think this is in part because they don't picture that they have **users*. 

But `Users` can really be anyone! It may start as the person developing the software but may expand to collaborators, random internet strangers, and others in the broader scientifiy community. The scientific community is full of users!

So in fact, many scientific researchers are doing *software development* everyday! But many don't have a computer science degree and many of them have never taken a programming class (That includes me -- I'm not sure how I got here!). Self-taught scientific programmers (like myself) may dismiss themselves as being software developers since they often think of programming as a means to an end -- a scientific question may be their main goal. But in the pursuit of that goal they are doing software development along the way!

The self-taught nature of many software programmers may also lead them to feel like they don't know what they are doing when it comes to programming and thus must not actually be software developers. But just because you are new to something, doesn't mean you aren't actually performing the skillset and doing the thing!

![](https://media.giphy.com/media/Dh5q0sShxgp13DwrvG/giphy.gif) 

But perhaps we should start including "software developer" into our identity schemas. Perhaps if we thought of this as one of our many hats we might be able to better adapt what more "traditionally trained" software developers do as a part of their development process. ([The Pragmatic Programmer](https://pragprog.com/) is a pretty big giant for discussing these skill sets and a good read).

![](https://media.giphy.com/media/pPr6b7vYj1en4ywCiT/giphy.gif)

What best practices do folks who are full-time "traditional" software developers use to do their work? This is where multidiscplinary bridges built between fields will really come in handy. 

I learned the most about software development when I worked in a lab that was very multidiscplinary and included computer scientists, user experience designers, back-end developers, and front-end developers. Each of these individuals had their own special skill sets that we could all benefit from learning from each other about. Any given individual can't possibly be an expert in all of these tasks, but if we all are doing a bit of software development, we should definitely try to learn from folks who might have been doing this work a bit longer. Then we can use our scientific knowledge and expertise to apply skills we learn from others to new applications! 

And this type of multidisciplinary collaboration is my favorite part about science! But warning, to fully utilize this kind of collaboration requires a lot of **soft skills** development...

**Examples:**

- Clear communication that is tailored to your audience. 
- Humility to recognize when something is outside your realm of knowledge. 
- Honesty and confidence to admit you don't know and that is okay!
- Patience to figure out communication with each other. 

.... And **soft** skills are actually really **hardest** but are really the foundation of everything else going smoothly! 


In conclusion: You're a <s>wizard</s> software developer, Harry

![](resources/images/youreadev.jpg)

*Acknowledgements to Sean Kross for inspiring this blog post in a conversation I had with him.*

<br> 
<script src="https://utteranc.es/client.js"
        repo="cansavvy/cansavvy_blog"
        issue-term="title"
        label="Commenter on blog post"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>

```{r}
sessionInfo()
```